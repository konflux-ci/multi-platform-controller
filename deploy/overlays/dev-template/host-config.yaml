apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    build.appstudio.redhat.com/multi-platform-config: hosts
  name: host-config
  namespace: multi-platform-controller
data:
  dynamic-platforms: linux/amd64,linux/s390x,linux-root/amd64,windows/c4xlarge-amd64
  dynamic-pool-platforms: linux/arm64
  instance-tag: INSTANCE_TAG

  dynamic.linux-arm64.type: aws
  dynamic.linux-arm64.region: us-east-1
  dynamic.linux-arm64.ami: ami-06f37afe6d4f43c47
  dynamic.linux-arm64.instance-type: t4g.medium
  dynamic.linux-arm64.key-name: AWS_SSH_KEY_NAME
  dynamic.linux-arm64.aws-secret: awsiam
  dynamic.linux-arm64.ssh-secret: awskeys
  dynamic.linux-arm64.security-group-id: sg-0dac40dc35d0bf1c4
  dynamic.linux-arm64.max-instances: "2"
  dynamic.linux-arm64.concurrency: "2"
  dynamic.linux-arm64.max-age: "10"
  dynamic.linux-arm64.subnet-id: subnet-02b7d6698c619e5a2
  dynamic.linux-arm64.strict-public-address: "true"

  dynamic.linux-amd64.type: aws
  dynamic.linux-amd64.region: us-east-1
  dynamic.linux-amd64.ami: ami-01aaf1c29c7e0f0af
  dynamic.linux-amd64.instance-type: m5.xlarge
  dynamic.linux-amd64.key-name: AWS_SSH_KEY_NAME
  dynamic.linux-amd64.aws-secret: awsiam
  dynamic.linux-amd64.ssh-secret: awskeys
  dynamic.linux-amd64.security-group-id: sg-0dac40dc35d0bf1c4
  dynamic.linux-amd64.max-instances: "4"
  dynamic.linux-amd64.subnet-id: subnet-02b7d6698c619e5a2
  dynamic.linux-amd64.strict-public-address: "true"

  dynamic.windows-c4xlarge-amd64.type: aws
  dynamic.windows-c4xlarge-amd64.region: us-east-1
  dynamic.windows-c4xlarge-amd64.ami: ami-0cf643428c5013531
  dynamic.windows-c4xlarge-amd64.instance-type: c5.4xlarge
  dynamic.windows-c4xlarge-amd64.key-name: AWS_SSH_KEY_NAME
  dynamic.windows-c4xlarge-amd64.aws-secret: awsiam
  dynamic.windows-c4xlarge-amd64.ssh-secret: awskeys
  dynamic.windows-c4xlarge-amd64.security-group-id: sg-0dac40dc35d0bf1c4
  dynamic.windows-c4xlarge-amd64.max-instances: "4"
  dynamic.windows-c4xlarge-amd64.subnet-id: subnet-02b7d6698c619e5a2
  dynamic.windows-c4xlarge-amd64.strict-public-address: "true"
  dynamic.windows-c4xlarge-amd64.user-data: |-
      <powershell>
      function Wait-Folder {
        param(
            [Parameter(Mandatory=$true)]
            [string]$FolderPath,

            [Parameter(Mandatory=$false)]
            [int]$TimeoutSeconds = 30
        )
        Write-Host "Waiting for folder '${FolderPath}' to be created"

        # Start a timer
        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

        while (-not (Test-Path -Path ${FolderPath})) {
          # Check if we have exceeded the timeout
          if ($stopwatch.Elapsed.TotalSeconds -ge $TimeoutSeconds) {
            Write-Error "Timeout reached! Folder was not created within $TimeoutSeconds seconds."
           $stopwatch.Stop()
            return $false
          }

          Write-Host "Waiting for folder..." -NoNewline
          Start-Sleep -Seconds 1
        }
        $stopwatch.Stop()

        return $true
      }

      ## -------------------------------------
      ## --------- Create Local User ---------
      ## -------------------------------------
      $user = "konflux-builder"
      if ((Get-LocalUser -Name "${user}" -ErrorAction SilentlyContinue) -eq $null) {
        $password = (-join([char[]](33..122) | Get-Random -Count 30)) # TODO: Can we do better?
        $securePassword = (ConvertTo-SecureString $password -AsPlainText -Force)

        # Create user
        New-LocalUser -Name $user -Password $securePassword -Description "Konflux Builder" | Out-Null
        Add-LocalGroupMember -Group 'Users' -Member "${user}"
        Add-LocalGroupMember -Group 'OpenSSH Users' -Member "${user}"

        # Create a Credential Object for the new user
        $userCred = New-Object System.Management.Automation.PSCredential($user, $securePassword)

        # Start a dummy Process as the new User
        # This is required to have the user home folder initialized.
        # TODO: can we do better?
        Start-Process -FilePath "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" `
                      -Credential ${userCred} `
                      -ArgumentList "-Command exit" `
                      -LoadUserProfile `
                      -WindowStyle Hidden `
                      -WorkingDirectory "C:\Users\" `
                      -Wait

        # Create a Key to login as user
        Write-Host "Creating SSH Key for user '${user}'"
        $tempKey = "${env:TEMP}\${user}"
        if (Test-Path "${tempKey}") { Remove-Item -Force "${tempKey}" }
        if (Test-Path "${tempKey}.pub") { Remove-Item -Force "${tempKey}.pub" }
        ssh-keygen -t rsa  -f "${tempKey}" -N `"`" | Out-Null

        # Move private key to a secure location and restrict access to it
        $privateKeyPath = "C:\Users\Administrator\${user}"
        mv "${env:TEMP}\${user}" "${privateKeyPath}"
        $ACL = Get-Acl "${privateKeyPath}"
        $Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("NT AUTHORITY\SYSTEM", "FullControl", "Allow")
        $ACL.SetAccessRule($Ar)
        $Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("BUILTIN\Administrators", "FullControl", "Allow")
        $ACL.SetAccessRule($Ar)
        Set-Acl "${privateKeyPath}" ${ACL}

        # Init home folder
        $userHome = "C:\Users\${user}"
        Write-Host "Waiting for User Home '${userHome}' to be created"

        # Ensure User's home folder is eventually created
        if (-not (Wait-Folder -FolderPath ${userHome})) {
          Write-Error "Folder '${userHome}' not found! Cleanup..." -ForegroundColor Red
          if (Test-Path "\${tempKey}") { Remove-Item -Force "${tempKey}" }
          if (Test-Path "\${tempKey}.pub") { Remove-Item -Force "${tempKey}.pub" }
          exit 1
        }

        # Set-up SSH Keys for User
        Write-Host "User Home found. Configuring SSH access" -ForegroundColor Green
        New-Item -ItemType Directory -Force -Path "${userHome}\.ssh"
        New-Item -ItemType Directory -Force -Path "${userHome}\build"

        # Copying and removing to preserve file permissions! Do not use `mv`! :)
        cp "${tempKey}.pub" "${userHome}\.ssh\authorized_keys"
        rm "${tempKey}.pub"
      }

      ## ---------------------------------------------
      ## --------- Enable Windows Containers ---------
      ## ---------------------------------------------
      Invoke-WebRequest -UseBasicParsing "https://raw.githubusercontent.com/microsoft/Windows-Containers/Main/helpful_tools/Install-DockerCE/install-docker-ce.ps1" -o install-docker-ce.ps1
      .\install-docker-ce.ps1 -NoRestart
      if (${global:RebootRequired}) {
        Restart-Computer
        exit
      }

      # Create docker-users group and add konflux-builder to it
      if ((Get-LocalGroup -Name 'docker-users') -eq $null) {
        New-LocalGroup -Name 'docker-users' -Description 'Docker Users'
      }
      if ((Get-LocalGroupMember -Group 'docker-users' -Member 'konflux-builder') -eq $null) {
        Add-LocalGroupMember -Group 'docker-users' -Member "${user}"
      }

      # allow the docker-users group to use docker
      $dockerConfigPath = "C:\ProgramData\docker\config\daemon.json"
      $existingConfig = Get-Content $dockerConfigPath -Raw | ConvertFrom-Json
      if ((${existingConfig}.group) -eq $null) {
        $existingConfig | Add-Member -NotePropertyName "group" -NotePropertyValue "docker-users" -Force
        $existingConfig | ConvertTo-Json -Depth 10 | Set-Content $dockerConfigPath
        Restart-Service docker
      }

      # Exclude docker in Windows Defender
      # TODO: performances get way better, but is this ok?
      Add-MpPreference -ExclusionProcess "dockerd.exe"
      Add-MpPreference -ExclusionProcess "docker.exe"
      Add-MpPreference -ExclusionProcess "containerd.exe"
      Add-MpPreference -ExclusionProcess "vmcompute.exe"

      ## -------------------------------------
      ## --------- Configure OpenSSH ---------
      ## -------------------------------------

      # Install OpenSSH Server
      Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0

      # Start the sshd service and set it to start automatically
      Start-Service sshd
      Set-Service -Name sshd -StartupType 'Automatic'

      # Grab the Public Key from AWS Metadata and configure authorized_keys
      # This allows you to log in with your .pem/.ppk file instead of a password
      $MAGIC_IP = "169.254.169.254"
      $IMDS_TOKEN = Invoke-RestMethod -Uri "http://${MAGIC_IP}/latest/api/token" -Method 'PUT' -Headers @{'X-aws-ec2-metadata-token-ttl-seconds' = '21600'}
      $PUBKEY = Invoke-RestMethod -Uri "http://${MAGIC_IP}/latest/meta-data/public-keys/0/openssh-key" -Headers @{'X-aws-ec2-metadata-token' = $IMDS_TOKEN}

      # Ensure SSH_PATH folder was created
      $SSH_PATH = "C:\ProgramData\ssh"
      Write-Host "Waiting for SSH Folder"
      if (-not (Wait-Folder -FolderPath ${SSH_PATH})) {
        Write-Error "Folder '${SSH_PATH}' not found! Exiting..." -ForegroundColor Red
        exit 1
      }
      Write-Host "Folder '${SSH_PATH}' found"

      # Add key to administrators_authorized_keys
      $PUBKEY | Out-File -FilePath "$SSH_PATH\administrators_authorized_keys" -Encoding ascii

      # Fix permissions (ACLs) for the authorized_keys file
      # OpenSSH is strict: only System and Administrators should have access
      $ACL = Get-Acl "$SSH_PATH\administrators_authorized_keys"
      $Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("NT AUTHORITY\SYSTEM", "FullControl", "Allow")
      $ACL.SetAccessRule($Ar)
      $Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("BUILTIN\Administrators", "FullControl", "Allow")
      $ACL.SetAccessRule($Ar)
      Set-Acl "$SSH_PATH\administrators_authorized_keys" $ACL

      # Restart sshd to apply key changes
      Restart-Service sshd

      # Configure the Firewall to allow SSH (Port 22)
      Remove-NetFirewallRule -Name 'OpenSSH-Server-In-TCP' | Out-Null
      New-NetFirewallRule -Name 'OpenSSH-Server-In-TCP' -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22 -RemoteAddress any
      Write-Output "Firewall Rule 'OpenSSH-Server-In-TCP' updated"
      </powershell>
      <persist>true</persist>

  dynamic.linux-root-amd64.type: "aws"
  dynamic.linux-root-amd64.region: "us-east-1"
  dynamic.linux-root-amd64.ami: ami-01aaf1c29c7e0f0af
  dynamic.linux-root-amd64.instance-type: "m6idn.2xlarge"
  dynamic.linux-root-amd64.key-name: AWS_SSH_KEY_NAME
  dynamic.linux-root-amd64.aws-secret: "awsiam"
  dynamic.linux-root-amd64.ssh-secret: "awskeys"
  dynamic.linux-root-amd64.security-group-id: sg-0dac40dc35d0bf1c4
  dynamic.linux-root-amd64.max-instances: "4"
  dynamic.linux-root-amd64.sudo-commands: "/usr/bin/podman"
  dynamic.linux-root-amd64.subnet-id: subnet-02b7d6698c619e5a2
  dynamic.linux-root-amd64.disk: "200"
  dynamic.linux-root-amd64.iops: "16000"
  dynamic.linux-root-amd64.throughput: "1000"
  dynamic.linux-root-amd64.strict-public-address: "true"
  dynamic.linux-root-amd64.user-data: |-
    Content-Type: multipart/mixed; boundary="//"
    MIME-Version: 1.0

    --//
    Content-Type: text/cloud-config; charset="us-ascii"
    MIME-Version: 1.0
    Content-Transfer-Encoding: 7bit
    Content-Disposition: attachment; filename="cloud-config.txt"

    #cloud-config
    cloud_final_modules:
      - [scripts-user, always]

    --//
    Content-Type: text/x-shellscript; charset="us-ascii"
    MIME-Version: 1.0
    Content-Transfer-Encoding: 7bit
    Content-Disposition: attachment; filename="userdata.txt"

    #!/bin/bash -ex

    if lsblk -no FSTYPE /dev/nvme1n1 | grep -qE '\S'; then
     echo "File system exists on the disk."
    else
     echo "No file system found on the disk /dev/nvme1n1"
     mkfs -t xfs /dev/nvme1n1
    fi

    mount /dev/nvme1n1 /home

    if [ -d "/home/var-lib-containers" ]; then
     echo "Directory '/home/var-lib-containers' exist"
    else
     echo "Directory '/home/var-lib-containers' doesn't exist"
     mkdir -p /home/var-lib-containers /var/lib/containers
    fi

    mount --bind /home/var-lib-containers /var/lib/containers

    if [ -d "/home/ec2-user" ]; then
    echo "ec2-user home exists"
    else
    echo "ec2-user home doesn't exist"
    mkdir -p /home/ec2-user/.ssh
    chown -R ec2-user /home/ec2-user
    fi

    sed -n 's,.*\(ssh-.*\s\),\1,p' /root/.ssh/authorized_keys > /home/ec2-user/.ssh/authorized_keys
    chown ec2-user /home/ec2-user/.ssh/authorized_keys
    chmod 600 /home/ec2-user/.ssh/authorized_keys
    chmod 700 /home/ec2-user/.ssh
    restorecon -r /home/ec2-user

    --//--
